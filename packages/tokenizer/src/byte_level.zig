/// ByteLevel pre-tokenizer - GPT-2 style byte-to-unicode mapping
/// Ported from: tokenizers/src/pre_tokenizers/byte_level.rs
/// Reference: https://github.com/openai/gpt-2/blob/master/src/encoder.py#L9
const std = @import("std");

/// Comptime-generated byte-to-char mapping table
/// Maps all 256 byte values to unicode characters
pub const BYTES_CHAR: [256]u21 = blk: {
    var table: [256]u21 = undefined;
    var n: u21 = 0;

    for (0..256) |b| {
        const byte: u8 = @intCast(b);
        // Printable ASCII ('!' to '~') and Latin-1 supplement stay as-is
        if ((byte >= '!' and byte <= '~') or
            (byte >= 0xA1 and byte <= 0xAC) or
            (byte >= 0xAE and byte <= 0xFF))
        {
            table[b] = byte;
        } else {
            // Control chars, space, etc. → 256 + n
            table[b] = 256 + n;
            n += 1;
        }
    }
    break :blk table;
};

/// Comptime-generated char-to-byte mapping table
/// Inverse of BYTES_CHAR
pub const CHAR_BYTES: [512]u8 = blk: {
    var table: [512]u8 = [_]u8{0} ** 512;
    for (0..256) |b| {
        const char_val = BYTES_CHAR[b];
        table[char_val] = @intCast(b);
    }
    break :blk table;
};

/// Transform raw bytes to byte-level unicode string
/// Each byte becomes a unicode character according to BYTES_CHAR mapping
pub fn encode(allocator: std.mem.Allocator, input: []const u8) ![]u8 {
    // Each byte becomes 1-2 UTF-8 bytes (chars 0-127 or 256-511)
    var result = try std.ArrayList(u8).initCapacity(allocator, input.len * 2);
    errdefer result.deinit(allocator);

    for (input) |byte| {
        const codepoint = BYTES_CHAR[byte];
        var buf: [4]u8 = undefined;
        const len = std.unicode.utf8Encode(codepoint, &buf) catch unreachable;
        try result.appendSlice(allocator, buf[0..len]);
    }

    return try result.toOwnedSlice(allocator);
}

/// Transform byte-level unicode string back to raw bytes
pub fn decode(allocator: std.mem.Allocator, input: []const u8) ![]u8 {
    var result = try std.ArrayList(u8).initCapacity(allocator, input.len);
    errdefer result.deinit(allocator);

    var i: usize = 0;
    while (i < input.len) {
        const cp_len = std.unicode.utf8ByteSequenceLength(input[i]) catch 1;
        if (i + cp_len > input.len) break;

        const codepoint = std.unicode.utf8Decode(input[i..][0..cp_len]) catch {
            try result.append(allocator, input[i]);
            i += 1;
            continue;
        };

        if (codepoint < 512) {
            try result.append(allocator, CHAR_BYTES[codepoint]);
        } else {
            // Unknown char - keep original bytes
            try result.appendSlice(allocator, input[i..][0..cp_len]);
        }
        i += cp_len;
    }

    return try result.toOwnedSlice(allocator);
}

/// Get the unicode character for a byte (no allocation)
pub inline fn byteToChar(byte: u8) u21 {
    return BYTES_CHAR[byte];
}

/// Get the byte for a unicode character (no allocation)
pub inline fn charToByte(char: u21) ?u8 {
    if (char < 512) {
        const byte = CHAR_BYTES[char];
        // Verify it's a valid mapping
        if (BYTES_CHAR[byte] == char) return byte;
    }
    return null;
}

// ============================================================================
// Tests
// ============================================================================

test "bytes_char mapping matches GPT-2" {
    // Space (0x20) → Ġ (U+0120 = 288)
    try std.testing.expectEqual(@as(u21, 288), BYTES_CHAR[0x20]);
    // Newline (0x0A) → Ċ (U+010A = 266)
    try std.testing.expectEqual(@as(u21, 266), BYTES_CHAR[0x0A]);
    // Printable ASCII stays as-is
    try std.testing.expectEqual(@as(u21, 'a'), BYTES_CHAR['a']);
    try std.testing.expectEqual(@as(u21, 'Z'), BYTES_CHAR['Z']);
    try std.testing.expectEqual(@as(u21, '!'), BYTES_CHAR['!']);
    try std.testing.expectEqual(@as(u21, '~'), BYTES_CHAR['~']);
}

test "encode/decode roundtrip" {
    const allocator = std.testing.allocator;

    const input = "Hello World!\n";
    const encoded = try encode(allocator, input);
    defer allocator.free(encoded);

    const decoded = try decode(allocator, encoded);
    defer allocator.free(decoded);

    try std.testing.expectEqualStrings(input, decoded);
}

test "encode space becomes Ġ" {
    const allocator = std.testing.allocator;

    const encoded = try encode(allocator, " ");
    defer allocator.free(encoded);

    // Ġ is U+0120, encoded as UTF-8: 0xC4 0xA0
    try std.testing.expectEqualSlices(u8, &[_]u8{ 0xC4, 0xA0 }, encoded);
}

test "encode newline becomes Ċ" {
    const allocator = std.testing.allocator;

    const encoded = try encode(allocator, "\n");
    defer allocator.free(encoded);

    // Ċ is U+010A, encoded as UTF-8: 0xC4 0x8A
    try std.testing.expectEqualSlices(u8, &[_]u8{ 0xC4, 0x8A }, encoded);
}
