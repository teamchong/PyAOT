/// Python threading module - Thread-based parallelism
const std = @import("std");
const h = @import("mod_helper.zig");

pub const Funcs = std.StaticStringMap(h.H).initComptime(.{
    .{ "Thread", h.c("struct { handle: ?std.Thread = null, name: ?[]const u8 = null, daemon: bool = false, pub fn start(s: *@This()) void { _ = s; } pub fn join(s: *@This()) void { if (s.handle) |hnd| hnd.join(); } pub fn is_alive(s: *@This()) bool { _ = s; return false; } pub fn getName(s: *@This()) ?[]const u8 { return s.name; } pub fn setName(s: *@This(), n: []const u8) void { s.name = n; } pub fn isDaemon(s: *@This()) bool { return s.daemon; } pub fn setDaemon(s: *@This(), d: bool) void { s.daemon = d; } }{}") },
    .{ "Lock", h.c("struct { mutex: std.Thread.Mutex = .{}, pub fn acquire(s: *@This()) void { s.mutex.lock(); } pub fn release(s: *@This()) void { s.mutex.unlock(); } pub fn locked(s: *@This()) bool { _ = s; return false; } pub fn __enter__(s: *@This()) *@This() { s.acquire(); return s; } pub fn __exit__(s: *@This(), _: anytype) void { s.release(); } }{}") },
    .{ "RLock", h.c("struct { mutex: std.Thread.Mutex = .{}, pub fn acquire(s: *@This()) void { s.mutex.lock(); } pub fn release(s: *@This()) void { s.mutex.unlock(); } pub fn locked(s: *@This()) bool { _ = s; return false; } pub fn __enter__(s: *@This()) *@This() { s.acquire(); return s; } pub fn __exit__(s: *@This(), _: anytype) void { s.release(); } }{}") },
    .{ "Condition", h.c("struct { cond: std.Thread.Condition = .{}, mutex: std.Thread.Mutex = .{}, pub fn acquire(s: *@This()) void { s.mutex.lock(); } pub fn release(s: *@This()) void { s.mutex.unlock(); } pub fn wait(s: *@This()) void { s.cond.wait(&s.mutex); } pub fn notify(s: *@This()) void { s.cond.signal(); } pub fn notify_all(s: *@This()) void { s.cond.broadcast(); } pub fn __enter__(s: *@This()) *@This() { s.acquire(); return s; } pub fn __exit__(s: *@This(), _: anytype) void { s.release(); } }{}") },
    .{ "Semaphore", h.c("struct { count: i64 = 1, mutex: std.Thread.Mutex = .{}, pub fn acquire(s: *@This()) void { s.mutex.lock(); s.count -= 1; s.mutex.unlock(); } pub fn release(s: *@This()) void { s.mutex.lock(); s.count += 1; s.mutex.unlock(); } pub fn __enter__(s: *@This()) *@This() { s.acquire(); return s; } pub fn __exit__(s: *@This(), _: anytype) void { s.release(); } }{}") },
    .{ "BoundedSemaphore", h.c("struct { count: i64 = 1, mutex: std.Thread.Mutex = .{}, pub fn acquire(s: *@This()) void { s.mutex.lock(); s.count -= 1; s.mutex.unlock(); } pub fn release(s: *@This()) void { s.mutex.lock(); s.count += 1; s.mutex.unlock(); } pub fn __enter__(s: *@This()) *@This() { s.acquire(); return s; } pub fn __exit__(s: *@This(), _: anytype) void { s.release(); } }{}") },
    .{ "Event", h.c("struct { flag: bool = false, mutex: std.Thread.Mutex = .{}, cond: std.Thread.Condition = .{}, pub fn set(s: *@This()) void { s.mutex.lock(); s.flag = true; s.cond.broadcast(); s.mutex.unlock(); } pub fn clear(s: *@This()) void { s.mutex.lock(); s.flag = false; s.mutex.unlock(); } pub fn is_set(s: *@This()) bool { s.mutex.lock(); defer s.mutex.unlock(); return s.flag; } pub fn wait(s: *@This()) void { s.mutex.lock(); while (!s.flag) s.cond.wait(&s.mutex); s.mutex.unlock(); } }{}") },
    .{ "Barrier", h.c("struct { parties: i64 = 1, count: i64 = 0, pub fn wait(s: *@This()) i64 { s.count += 1; return s.count - 1; } pub fn reset(s: *@This()) void { s.count = 0; } pub fn abort(s: *@This()) void { _ = s; } }{}") },
    .{ "Timer", h.c("struct { interval: f64 = 0, pub fn start(s: *@This()) void { _ = s; } pub fn cancel(s: *@This()) void { _ = s; } }{}") },
    .{ "current_thread", h.c("struct { handle: ?std.Thread = null, name: ?[]const u8 = null, daemon: bool = false, pub fn start(s: *@This()) void { _ = s; } pub fn join(s: *@This()) void { if (s.handle) |hnd| hnd.join(); } pub fn is_alive(s: *@This()) bool { _ = s; return false; } pub fn getName(s: *@This()) ?[]const u8 { return s.name; } pub fn setName(s: *@This(), n: []const u8) void { s.name = n; } pub fn isDaemon(s: *@This()) bool { return s.daemon; } pub fn setDaemon(s: *@This(), d: bool) void { s.daemon = d; } }{}") },
    .{ "main_thread", h.c("struct { handle: ?std.Thread = null, name: ?[]const u8 = null, daemon: bool = false, pub fn start(s: *@This()) void { _ = s; } pub fn join(s: *@This()) void { if (s.handle) |hnd| hnd.join(); } pub fn is_alive(s: *@This()) bool { _ = s; return false; } pub fn getName(s: *@This()) ?[]const u8 { return s.name; } pub fn setName(s: *@This(), n: []const u8) void { s.name = n; } pub fn isDaemon(s: *@This()) bool { return s.daemon; } pub fn setDaemon(s: *@This(), d: bool) void { s.daemon = d; } }{}") },
    .{ "active_count", h.I64(1) }, .{ "enumerate", h.c("&[_]@TypeOf(struct{}{}){}") },
    .{ "local", h.c("struct { data: hashmap_helper.StringHashMap([]const u8) = hashmap_helper.StringHashMap([]const u8).init(__global_allocator) }{}") },
});
